model3$marginals.hyperpar[[1]])
post.sigma4 = inla.tmarginal(function(x) sqrt(1/x),
model4$marginals.hyperpar[[1]])
plot(inla.smarginal(post.sigma),type="l",xlab="",
ylab="",main=expression(paste("Posterior distribution ", sigma)))
lines(inla.smarginal(post.sigma3),col=2)
lines(inla.smarginal(post.sigma4),col=3)
abline(v=sigma)
legend("topright",col=c(1,2,3),lty=c(1,1,1),
legend=c("Default","Normal(0,1)","logGamma(1,0.01)"),box.lty=0)
#pdf("posterioris2.pdf", width=12, height=4)
par(mfrow=c(1,3))
### --- Intercept --- ###
plot(inla.smarginal(post.beta0),type="l",xlab="",ylab="",
main=expression(paste("Posterior distribution ", beta[0])))
lines(inla.smarginal(model2$marginals.fixed[[1]]), col="red")
abline(v=beta.0)
legend("topleft",col=c(1,2),lty=c(1,1),
legend=c("Default","Normal(0,0.0001)"),box.lty=0)
### --- Slope --- ###
plot(inla.smarginal(post.beta1),type="l",xlab="",ylab="",
main=expression(paste("Posterior distribution ", beta[1])))
lines(inla.smarginal(model2$marginals.fixed[[2]]), col="red")
abline(v=beta.1)
legend("topleft",col=c(1,2),lty=c(1,1),
legend=c("Default","Normal(0,1)"),box.lty=0)
### --- Deviation --- ###
plot(inla.smarginal(post.sigma),type="l",xlab="",
ylab="",main=expression(paste("Post. marg. of ", sigma)))
lines(inla.smarginal(post.sigma3),col=2)
lines(inla.smarginal(post.sigma4),col=3)
abline(v=sigma)
legend("topright",col=c(1,2,3),lty=c(1,1,1),
legend=c("Default","Normal(0,1)","logGamma(1,0.01)"),box.lty=0)
#dev.off()
library(INLA)
library(dplyr)
#Model:     logit(pi) = beta0 + beta1*x1 + beta2*x2 + random.effect(plate)
data(Seeds)
Seeds$x1 <- factor(Seeds$x1, labels=c("ae75", "ae73"))
Seeds$x2 <- factor(Seeds$x2, labels=c("bean", "cucumber"))
Seeds
str(Seeds)
### --- 2. Defining the formula and fitting the model --- ####
### ----- 2.1. Without random effects --- ###
formula1 <- r ~ 1 + x1 + x2
mod1.seeds = inla(formula1,
data            = Seeds,
family          = "binomial",
Ntrials         = Seeds$n,
control.compute = list(dic = TRUE,
waic = TRUE,
cpo = TRUE))
summary(mod1.seeds)
inla.pmarginal(0, mod1.seeds$marginals.fixed$x1ae73)
### ----- 2.2. Interactions between factors --- ####
formula2 <- r ~  1 + x1*x2
mod2.seeds = inla(formula2,
data            = Seeds,
family          = "binomial",
Ntrials         = Seeds$n,
control.compute = list(dic = TRUE,
waic = TRUE,
cpo = TRUE))
mod.seeds = inla(formula,
data            = Seeds,
family          = "binomial",
Ntrials         = n,
control.compute = list(dic  = TRUE,
waic = TRUE))
# To change priors for the hyperparameter: 'f(plate, model="iid",param=c(a,b))';
# Precision for the hyperparameter ~ Gamma(a,b)
# By default precision ~ Gamma(1, 0.00005), we can change
mod.seeds = inla(formula,
data            = Seeds,
family          = "binomial",
Ntrials         = n,
control.compute = list(dic  = TRUE,
waic = TRUE))
formula <- r ~ 1 + x1*x2 + f(plate,
model  = "iid",
hyper  = list(theta = list(prior = "loggamma",
param = c(1,0.01))))
# To change priors for the hyperparameter: 'f(plate, model="iid",param=c(a,b))';
# Precision for the hyperparameter ~ Gamma(a,b)
# By default precision ~ Gamma(1, 0.00005), we can change
mod.seeds = inla(formula,
data            = Seeds,
family          = "binomial",
Ntrials         = n,
control.compute = list(dic  = TRUE,
waic = TRUE))
data(Seeds)
data <- data(Seeds)
data
data(Seeds)
Seeds
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(rnaturalearth)
install.packages("rnaturalearthdata")
library(INLA)
?strategy
?control.inla
?control.mode
?inla.mode
?control.inla
?control.inla
setwd("C:/Users/jossk/GITHUB/PUBLIC/Bayesian-INLA")
### --- 0. Loading libraries --- ####
library(INLA)
library(dplyr)
#Model:     logit(pi) = beta0 + beta1*x1 + beta2*x2 + random.effect(plate)
data(Seeds)
Seeds$x1 <- factor(Seeds$x1, labels=c("ae75", "ae73"))
Seeds$x2 <- factor(Seeds$x2, labels=c("bean", "cucumber"))
Seeds
str(Seeds)
### --- 2. Defining the formula and fitting the model --- ####
### ----- 2.1. Without random effects --- ###
formula1 <- r ~ 1 + x1 + x2
mod1.seeds = inla(formula1,
data            = Seeds,
family          = "binomial",
Ntrials         = Seeds$n,
control.compute = list(dic = TRUE,
waic = TRUE,
cpo = TRUE))
summary(mod1.seeds)
inla.pmarginal(0, mod1.seeds$marginals.fixed$x1ae73)
### ----- 2.2. Interactions between factors --- ####
formula2 <- r ~  1 + x1*x2
mod2.seeds = inla(formula2,
data            = Seeds,
family          = "binomial",
Ntrials         = Seeds$n,
control.compute = list(dic = TRUE,
waic = TRUE,
cpo = TRUE))
summary(mod2.seeds)
### ----- 2.2. Random effects are introduced to the model using the function 'f()' --- ###
Seeds$plate
formula <- r ~ 1 + x1*x2 + f(plate,
model  = "iid",
hyper  = list(theta = list(prior = "loggamma",
param = c(1,0.01))))
# To change priors for the hyperparameter: 'f(plate, model="iid",param=c(a,b))';
# Precision for the hyperparameter ~ Gamma(a,b)
# By default precision ~ Gamma(1, 0.00005), we can change
mod.seeds = inla(formula,
data            = Seeds,
family          = "binomial",
Ntrials         = n,
control.compute = list(dic  = TRUE,
waic = TRUE))
summary(mod.seeds)
### --- 3. Best model --- ####
selection <- data.frame(DIC = c(mod1.seeds$dic$dic, mod2.seeds$dic$dic, mod.seeds$dic$dic),
WAIc=c(mod1.seeds$waic$waic, mod2.seeds$waic$waic, mod.seeds$waic$waic))
rownames(selection)<-c("mod1.seeds", "mod2.seeds", "mod.seeds")
selection
### --- 4. Posterior distribution --- ####
summary.random <- mod.seeds$summary.random$plate
round(head(summary.random),3)
### --- Posterior distribution of the standard deviation --- ###
### Transform precision in the standard deviation
sigma.v <- inla.tmarginal(function(x) sqrt(1/x),
mod.seeds$marginals.hyperpar[[1]])
plot(sigma.v)
### --- Plot  --- ###
#pdf("posteriori_v.pdf", width=5, height=5)
plot(inla.smarginal(sigma.v),type="l",xlab="",
ylab="",main=expression(paste("Posterior distribution ", sigma)))
hpd.sigma = inla.hpdmarginal(p=0.95, sigma.v)
plot(inla.smarginal(sigma.v),type="l",xlab="",
ylab="",main=expression(paste("Posterior distribution ", sigma)))
hpd.sigma = inla.hpdmarginal(p=0.95, sigma.v)
abline(v=hpd.sigma[1],lty=2,col=2)
abline(v=hpd.sigma[2],lty=2,col=2)
#dev.off()
### --- Summary --- ###
inla.zmarginal(sigma.v)
### --- 5. Probability to be positive the coefficient associated with x2? --- ####
# Pr(beta_x2 > 0)?
1 - inla.pmarginal(0, mod.seeds$marginals.fixed$x2)
library(dplyr)
library(ggplot2)
library(INLA)
# Ascospores data
# data <- readRDS("../data/data_khaki/alcudiadata_01-01.RDS")
# data <- data %>%
#   select(prop, Fe, anyo, dd) %>%
#   filter(dd <= 40)
#
# data$prop <- DirichletReg::DR_data(data$prop)[,2]
# colnames(data) <- c("y", "date", "year", "dd")
# writexl::write_xlsx(data, "../data/data_khaki/data_alcudia.xlsx")
#
data <- readxl::read_excel("data_alcudia.xlsx")
data$year <- factor(data$year)
data <- data %>%
dplyr::select(y, year, dd)
head(data)
ggplot(data) +
geom_point(aes(x = dd, y = y, col = year))+
theme_bw() +
theme(legend.position = "bottom") +
scale_color_brewer(palette="Dark2") +
xlab("dd ( x 100)")
formula0 <- y ~ + 1
mod0 <- inla(formula0,
family            = "beta",
data              = data,
control.family    = list(link  = "logit"),
control.compute   = list(dic    = TRUE,
cpo    = TRUE,
waic   = TRUE),
control.predictor = list(compute = TRUE))
formula1 <- y ~ + 1 + dd
mod1 <- inla(formula1,
family            = "beta",
data              = data,
control.family    = list(link  = "logit"),
control.compute   = list(dic    = TRUE,
cpo    = TRUE,
waic   = TRUE),
control.predictor = list(compute = TRUE))
data$year_ind <- as.numeric(data$year)
prior1_tau <- list(prec = list(prior = 'pc.prec', param = c(5, 0.01)))
formula2 <- y ~ + 1 + dd +
f(year_ind, model='iid',
hyper = prior1_tau)
mod2 <- inla(formula2,
family            = "beta",
data              = data,
control.family    = list(link  = "logit"),
control.compute   = list(config = TRUE,
dic    = TRUE,
cpo    = TRUE,
waic   = TRUE),
control.predictor = list(compute = TRUE))
selection <- data.frame(DIC  = c(mod0$dic$dic, mod1$dic$dic, mod2$dic$dic),
WAIC = c(mod0$waic$waic, mod1$waic$waic, mod2$waic$waic),
LCPO = c(-mean(log(mod0$cpo$cpo)),
-mean(log(mod1$cpo$cpo)),
-mean(log(mod2$cpo$cpo))))
rownames(selection)<- c("Null model", "DD", "DD + year")
selection
mod2$summary.fixed %>% round(., 4)
post_margs <- mod2$marginals.fixed %>%
lapply(., inla.smarginal) %>%
do.call(rbind.data.frame, .)
rownames(post_margs) %>%
stringr::str_split(., "\\.") %>%
purrr::map(., 1) %>% unlist(.) -> post_margs$variable
ggplot(post_margs, aes(x = x, y = y)) +
geom_line(aes(color = variable)) +
facet_wrap(~variable, ncol = 2, scales = "free") +
theme_bw() +
theme(legend.position = "none")
mod2$summary.hyperpar %>% round(., 4)
#Standard deviation of the random effect year
sd_re <- inla.tmarginal(function(x)1/sqrt(x), mod2$marginals.hyperpar$`Precision for year_ind`)
#Precision of the beta effect
prec_beta <- inla.smarginal(mod2$marginals.hyperpar$`precision parameter for the beta observations`)
#Joining both
hyperpars <- rbind(data.frame(sd_re, hyp1 = "sigma-year"),
data.frame(prec_beta, hyp1 = "prec-beta"))
hyperpars$hyp1 <- factor(hyperpars$hyp1)
#Plotting
ggplot(hyperpars, aes(x = x, y = y)) +
geom_line(aes(color = hyp1), linewidth = 1.3) +
facet_wrap(~ hyp1, ncol = 2, scales = "free") +
theme_bw() +
theme(legend.position = "none")
p1 <- 1 - inla.pmarginal(0, mod2$marginals.fixed$dd)
### ----- 4.2. Predictions --- ####
x_dd <- seq(5, 40, 0.5)
data_pred <- data.frame(y = NA,
year = 2016,
dd   = x_dd,
year_ind = (max(data$year_ind) + 1))
data_total <- rbind(data,
data_pred)
formula2
mod2.pred <- inla(formula2,
family            = "beta",
data              = data_total,
control.family    = list(link  = "logit"),
control.compute   = list(config = TRUE,
dic    = TRUE,
cpo    = TRUE,
waic   = TRUE),
control.predictor = list(compute = TRUE,
link    = 1),
control.mode      = list(theta = mod2$mode$theta,
restart = TRUE),
verbose = FALSE)
predictive <- mod2.pred$summary.fitted.values[-c(1:dim(data)[1]),]
predictive <- cbind(data_pred, predictive)
colnames(predictive) <- c("y", "year", "dd", "year_ind", "mean", "sd", "Quant025", "Quant50", "Quant975", "mode")
predictive <- mod2.pred$summary.fitted.values[-c(1:dim(data)[1]),]
predictive <- cbind(data_pred, predictive)
colnames(predictive) <- c("y", "year", "dd", "year_ind", "mean", "sd", "Quant025", "Quant50", "Quant975", "mode")
ggplot() +
geom_line(data = predictive, aes(x = dd, y = Quant50)) +
geom_ribbon(data = predictive,
aes(x = dd,
ymin = Quant025,
ymax = Quant975), alpha = 0.1) +
geom_point(data = data, aes(x = dd, y = y, col = year))+
theme_bw() +
theme(legend.position = "bottom") +
scale_color_brewer(palette="Dark2") +
xlab("dd ( x 100)")
knitr::opts_chunk$set(echo = TRUE)
library(sf)
library(tidyverse)
library(INLA)
library(readxl)
library(dplyr)
library(RColorBrewer)
library(patchwork)
library(spdep)
library(leaflet)
# Read the spatial data (shapefile)
VR.sf <- st_read("Valencian_Region_Oral_Cancer.shp", quiet = TRUE)
# Check the structure of the spatial data
print(st_geometry(VR.sf))
head(VR.sf)
# Prepare SMR and Population data
VR.sf <- VR.sf %>%
mutate(
SMR = 100 * Obs / Exp,
cut_smr = cut(SMR,
breaks = c(-0.1, 85, 90, 95, 100, 105, 110, 115, 1e+07),
include.lowest = TRUE),
cut_pop = cut(Population,
breaks = c(0, quantile(Population, probs = seq(0, 1, length.out = 7))),
include.lowest = TRUE)
)
# SMR
colors_smr <- brewer.pal(8, "BrBG")[8:1]
# Create the ggplot map
smr_map <- ggplot(VR.sf) +
geom_sf(aes(fill = cut_smr),
color = "gray10", # Border color
linewidth = 0.1) +  # Adjust border thickness
scale_fill_manual(
values = colors_smr,                                    # Use custom palette
name = "SMR",                                           # Legend title
labels = c("<85", "85-90", "90-95", "95-100", "100-105", "105-110", "110-115", ">120") # Custom legend labels
) +
labs(title = "SMR") +      # Add title
theme_minimal() +                                          # Clean theme
theme(
legend.position = "bottom",                             # Legend at bottom
legend.key.width = unit(0.7, "cm"),                       # Adjust legend size
legend.key.height = unit(0.3, "cm"),
panel.grid = element_blank(),
legend.title = element_blank(),
# Remove gridlines for cleaner map
axis.text = element_blank(),                            # Remove axis text
axis.ticks = element_blank(),                            # Remove axis ticks
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"), # Center and style the title
) +
guides(fill=guide_legend(ncol=2))
# Population
# Define the color palette
colors_pop <- brewer.pal(7, "Oranges")
# Create the ggplot map
population_map <- ggplot(VR.sf) +
geom_sf(aes(fill = cut_pop), color = "gray10",  linewidth = 0.01)+   # Map `fill` to `cut_pop`, gray borders
scale_fill_manual(
values = colors_pop,                                    # Use custom palette
name = "Population",                                    # Legend title
labels = c("Low", "", "", "", "", "", "High")           # Custom legend labels
) +
labs(title = "Population") +
theme_minimal() +                                    # Clean theme
theme(
panel.grid = element_blank(),                           # Remove gridlines for cleaner map
axis.text = element_blank(),                            # Remove axis text
axis.ticks = element_blank(),
legend.title = element_blank(),
legend.position = "bottom",                             # Legend at bottom
legend.key.width = unit(0.7, "cm"),                       # Adjust legend size
legend.key.height = unit(0.3, "cm"),                     # Adjust legend height
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"), # Center and style the title
) +
guides(fill=guide_legend(ncol=2))
smr_map + population_map
VR.sf %>%
filter(SMR> 500) %>%
arrange(desc(SMR)) %>%
select(NOMBRE, Population, Obs, SMR) %>%
as.data.frame(.) %>%
select(-geometry) %>%
knitr::kable(.)
# Create neighbor relationships
temp <- poly2nb(VR.sf)
# Save the neighbor graph for INLA
nb2INLA("VR.graph", temp)
# Load the graph into INLA
H <- inla.read.graph(filename = "VR.graph")
# Visualize the adjacency matrix of the graph
image(inla.graph2matrix(H), xlab = "", ylab = "")
# Function to visualize neighbors on the map
plot_map_neig_ggplot <- function(neig, VR.sf, temp) {
# Base map of the Valencian Region
p <- ggplot() +
geom_sf(data = VR.sf, fill = "white", color = "black") +                    # Base map
geom_sf(data = VR.sf[neig, ], fill = "red", color = "black") +              # Selected region
geom_sf(data = VR.sf[temp[[neig]], ], fill = "blue", color = "black") +     # Neighbor regions
theme_minimal() +
ggtitle(paste("Selected region:", VR.sf$NOMBRE[neig])) +                    # Title
theme(plot.title = element_text(hjust = 0.5))                              # Center the title
# Print the plot
print(p)
# Print neighbor information
cat("You have selected", VR.sf$NOMBRE[neig], "and its neighbors are:", "\n")
cat(VR.sf$NOMBRE[temp[[neig]]], "\n")
}
# Example: Plot neighbors for selected municipalities
plot_map_neig_ggplot(neig = 525, VR.sf, temp = temp)
VR.sf <- VR.sf %>%
mutate(S = as.numeric(row_number())) # Unstructured effect IDs
sdunif="expression:
logdens=-log_precision/2;
return(logdens)"
formula <- Obs ~ 1 +
f(S,
model = "bym",
graph = H,
scale.model = TRUE,
hyper=list(prec.spatial=list(prior=sdunif),
prec.unstruct=list(prior=sdunif)))
mod.disease <- inla(formula,
family = "poisson",
data = VR.sf,
E = Exp,
control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE),
control.predictor = list(compute = TRUE, cdf = c(log(1))))
summary(mod.disease)
VR.sf <- VR.sf %>%
mutate(SMR_mean = mod.disease$summary.fitted.values$mean,
SMR_sd = mod.disease$summary.fitted.values$sd,
SMR_median = mod.disease$summary.fitted.values$`0.5quant`,
SMR_q025 = mod.disease$summary.fitted.values$`0.025quant`,
SMR_q975 = mod.disease$summary.fitted.values$`0.975quant`,
SMR_p1 = 1 - mod.disease$summary.fitted.values$`1cdf`)
SMR.cutoff <- c(-0.1, 85, 90, 95, 100, 105, 110, 115, 1e+07)
SMR_p1.cutoff <- c(0, 0.2, 0.6, 0.8, 1)
VR.sf <- VR.sf %>%
mutate(SMR_disc = cut(SMR_mean*100, breaks = SMR.cutoff, include.lowest = TRUE,
labels = c("<85", "85-90", "90-95", "95-100", "100-105", "105-110", "110-115", ">120")),
SMR_p1_disc = cut(SMR_p1, breaks = SMR_p1.cutoff, include.lowest = TRUE))
SMR_fitted <- ggplot(VR.sf) +
geom_sf(aes(fill = SMR_disc),
color = "gray10", # Border color
linewidth = 0.1) +  # Adjust border thickness
scale_fill_manual(
values = colors_smr,                                    # Use custom palette
name = "SMR",                                           # Legend title
labels = c("<70", "70-90", "90-95", "95-100", "100-105", "105-110", "110-130", ">130"),
drop = FALSE
)+
labs(title = "SMR") +      # Add title
theme_minimal() +                                          # Clean theme
theme(
legend.position = "bottom",                             # Legend at bottom
legend.key.width = unit(0.7, "cm"),                       # Adjust legend size
legend.key.height = unit(0.3, "cm"),
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"), # Center and style the title
panel.grid = element_blank(),
legend.title = element_blank(),
# Remove gridlines for cleaner map
axis.text = element_blank(),                            # Remove axis text
axis.ticks = element_blank()                            # Remove axis ticks
) +
guides(fill=guide_legend(ncol=2))
smr_map | SMR_fitted
# Plotting SMR Probability > 1
# Define custom labels for the categories
custom_labels <- c("Low Risk", "Moderate Risk", "Elevated Risk", "High Risk")
colors_SMR_risk <- brewer.pal(8, "Oranges")[seq(2, 8, by  = 2)]
# Update SMR_disc2
SMR_disc2 <- ggplot(data = VR.sf) +
geom_sf(aes(fill = SMR_p1_disc),
color = "gray10", # Border color
linewidth = 0.1) +  # Adjust border thickness
scale_fill_manual(
values = colors_SMR_risk,  # Custom palette for 4 categories
name = "SMR Risk Levels",                                       # Legend title
labels = custom_labels,                                         # Custom labels
drop = FALSE                                                    # Include unused levels
) +
labs(title = "SMR P(>1) Categories") +                            # Add title
theme_minimal() +                                                 # Clean theme
theme(
legend.position = "bottom",                                     # Legend at bottom
legend.key.width = unit(0.7, "cm"),                             # Adjust legend size
legend.key.height = unit(0.3, "cm"),
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"), # Center and style the title
panel.grid = element_blank(),
legend.title = element_blank(),                                 # Remove legend title
axis.text = element_blank(),                                    # Remove axis text
axis.ticks = element_blank()                                    # Remove axis ticks
) +
guides(fill = guide_legend(ncol = 1))                             # Two-column legend
# Display the updated plot
print(SMR_disc2)
smr_map | SMR_fitted | SMR_disc2
